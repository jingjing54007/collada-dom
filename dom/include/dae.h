/*				  /
 * Copyright 2006 Sony Computer Entertainment Inc.
 *
 * Licensed under the MIT Open Source License, for details please see license.txt or the website
 * http://www.opensource.org/licenses/mit-license.php
 *
 */

#ifndef __COLLADA_DOM__DAE_H__
#define __COLLADA_DOM__DAE_H__

#include "dae/domAny.h"
#include "dae/daeAtlas.h"
#include "dae/daeDocument.h"

COLLADA_(namespace)
{//-.
//<-'

/**GCC/C++ want this lifted up out of @c daeDocRoot.
 */
template<class S> struct daeDocRootAware
{
	typedef typename S::__COLLADA__T type;
};
template<>
struct daeDocRootAware<void>{ typedef daeElement type; };
template<>
struct daeDocRootAware<void*>{ typedef daeElement type; };

/**
 * @c daeDocRoot lets APIs return the doc in addition to the root.
 * Technically, @c daeDocRoot extracts the doc's XML-like root on
 * demand when it is assigned to a @c daeSmartRef that can hold a
 * type of root suiting @a T. A @c daeError code is also included.
 */
template<class T> struct daeDocRoot : daeDocRef, daeOK
{
	typedef typename daeDocRootAware<T>::type TT;

	using daeDocRef::operator=; //using daeOK::operator=; //C4522

	//NOTE: daeConstOf is added to implement daeArchive::getDoc().

	daeDocRoot(){}
	daeDocRoot(daeOK cp):daeOK(cp){}
	daeDocRoot(daeError cp):daeOK(cp){}
	daeDocRoot(const daeDocRef &cp):daeDocRef(cp),daeOK(cp){}
	daeDocRoot(const daeDocRoot<> &cp):daeDocRef(cp),daeOK(cp){}		
	template<class U>
	daeDocRoot &operator=(const daeDocRoot<U> &cp)
	{
		_assign((typename daeDocRootAware<U>::type*)nullptr,cp); 
		error = cp.error; return *this;
	}	
	//This is letting daeDocRoot<> assign to anything.
	//const sidesteps case where T is an xs::any type.
	void _assign(daeElement*, const daeDocRef &cp){ *this = cp; }	
	void _assign(const TT*, const daeDocRef &cp){ *this = cp; }
	void _assign(...){ daeCTC<0>(); }

	template<class S> operator S*()const
	{ 
		return (typename daeConstOf<T,S>::type*)_SFINAE<S>((S*)nullptr);
	}	
	template<template<class> class R, class S> operator R<S>()const
	{
		return (typename daeConstOf<T,S>::type*)_SFINAE<S>((S*)nullptr);
	}
	operator typename daeConstOf<T,daeDocument>::type*()const
	{
		return daeDocRef::operator->()->_getDocument(); 
	}
	operator daeSmartRef<typename daeConstOf<T,daeDocument>::type>()const
	{
		return daeDocRef::operator->()->getDocument(); 
	}
	template<class S> typename daeConstOf<T,daeObject>::type *_SFINAE(...)const
	{
		return daeDocRef::operator->(); 
	}	
	template<class S> daeObject *_SFINAE(const DAEP::Element*)const
	{ 
		return _SFINAE<S>((daeElement*)nullptr); 
	}
	template<class S> daeObject *_SFINAE(const daeElement*)const
	{ 
		//LEGACY: Since _read2 was changed it's possible to get an 
		//error with a nonzero daeDocRef. If the result is converted
		//into a high level element/document it becomes a nullptr value.
		if(error!=DAE_OK) return nullptr;

		//& is used to invoke the DAEP::Element conversion
		//to a daeElement& in order to behave like xs::any.
		S &upcast = *(TT*)nullptr; (void)upcast;
		if(*this==COLLADA_(nullptr)) return nullptr;
		daeElement *root = (*this)->getDocument()->getRoot(); 
		daeSafeCast<TT>(root); return root;
	}
};

#include "./LINKAGE.HPP" //#define LINKAGE

/**ZAE
 * Class @c daeDOM is based on @c daeArchive. COLLADA ZAE archives are @c daeArchives.
 */
class daeArchive : public daeDoc
{		
	friend class daeDOM;
	friend class daeDoc;		
	friend class daeIORequest;
	friend class DAEP::Object;
	/**
	 * Disabling @c new operator for clients.
	 * This is here because @c daeDOM, can't
	 * be deleted by a @c daeSmartRef, since
	 * @c __DAEP__Make__v1__delete() must be
	 * generated by @c __daeDOM__construct().
	 * @c _isDOM() needs the 0 process-share.
	 * @see @c daeDOM::_addArchive().
	 */
	void *operator new(size_t n)
	{
		return ::operator new(n); //NOP 
	}	

COLLADA_(public) //OPERATORS
	/** 
	 * Placement-new wants this on MSVC2015. 
	 * There's no reason for this to be @c public,
	 * -but neither is there reason for it to not be so.
	 */
	void *operator new(size_t, void *p){ return p; }

	COLLADA_DOM_OBJECT_OPERATORS(daeArchive)

COLLADA_(public/*private*/) //new/openDoc() implementation
	
	//These had returned the doc-root via specializations,
	//but GCC/C++ forbid in-class explicit specialization.
	template<class ROOT> 
	/** Creates/recreates a @a ROOT rooted doc. */	
	inline void _read(daeDocRoot<ROOT> &o, const daeIORequest &req, daeIOPlugin *I)
	{
		o.error = _read2(o,daeGetMeta<ROOT>(),req,I);
	}
	/**TEMPLATE-SPECIALIZATION
	 * Delegates creation/recreation of a new doc to @c daePlatform::openURI().
	 * If @a !req.localURI->getAllowsAny(), then @c DAE_ERR_NOT_IMPLEMENTED is
	 * returned before resorting to populating the doc with @c domAny elements.
	 * (@c daeIORequest::unfulfillRequest() is provided just for this purpose.)
	 * (@c _read<void*>() is provided below to automatically "setAllowsAny()".)
	 */	
	inline void _read(daeDocRoot<> &o, const daeIORequest &req, daeIOPlugin *I)
	{
		o.error = _getPlatform(*getDOM()).openURI(req,I,(daeURIRef&)o);
		if(o!=COLLADA_(nullptr)&&!(o=(daeDoc*)&o->getParentObject())->_isDoc())
		{
			//Hate to inline this logic, but openURI() is designed so to support
			//non-doc based URIs (in the future) and this is a doc-based routine.
			o = nullptr; o.error = DAE_ERR_CLIENT_FATAL; assert(0);
		}
	}
	/**TEMPLATE-SPECIALIZATION	 
	 * Delegates creation/recreation of a new doc to @c daePlatform::openURI(), with
	 * further instructions to default/fallback to a @c domAny based doc if required. 
	 * The * in "void*" is an asterisk. It's to illustrate that @c domAny isn't free.
	 * @warning This is NOT RECOMMENDED if @a URI is part of, or bound to a document.
	 */
	inline void _read(daeDocRoot<void*> &o, const daeIORequest &req, daeIOPlugin *I)
	{
		const_cast<daeURI&>(*req.localURI).setAllowsAny(); _read(*(daeDocRoot<>*)&o,req,I);
	}

	/**
	 * Creates/recreates a new document. 
	 * @todo There needs to be a wildcard @c daeMetaElement to have any root element,
	 * on a per namespace basis, as not all XML Schema are as restrictive as COLLADA.
	 *
	 * ZAE
	 * @param o may be recycled in order to facilitate recursive operations, such as
	 * how @c daeZAEPlugin will produce the index document given sufficient metadata.
	 */
	LINKAGE static daeError _read2(daeDocRef &o, daeMeta*, const daeIORequest&, daeIOPlugin*);

COLLADA_(public) //ACCESSORS & MUTATORS
	/**
	 * Creates/recreates an empty doc/document. 
	 * @note Originally the idea was to have @c newDoc<void>() create a
	 * new empty doc/document, but instead that's like @c openDoc<void>().
	 */
	inline daeDocRoot<> newDoc(const daeURI &URI, daeIOPlugin *I=nullptr)
	{ 
		daeDocRoot<> o; o.error = _read2(o,nullptr,daeIORequest(this,nullptr,&URI),I); return o;
	}	

	template<class ROOT>
	/** 
	 * Creates/recreates a @a ROOT rooted doc/document.
	 * This is identical to @c openDoc<ROOT>() except that a new doc/document
	 * is created and a root node is set up and returned. 
	 * @tparam ROOT if @c void or @c void* is given to @c daePlatform::openURI().
	 * It must decided based on @a URI what
	 */
	inline daeDocRoot<ROOT> newDoc(const daeURI &URI, daeIOPlugin *I=nullptr)
	{ 
		daeDocRoot<ROOT> o; _read(o,daeIORequest(this,nullptr,&URI),I); return o;
	}	
	//A newDoc<domAny>() version is all included for completeness.
	template<class T>
	/** This is a dummy to force writing "<domAny>"; and reserved. */
	inline daeDocRoot<T> newDoc(const daeName &QName, const daeURI &URI, daeIOPlugin *I=nullptr)
	{
		daeDocRoot<T> o; _anyDoc(o,QName,URI,I); return o;
	}
	/**TEMPLATE-SPECIALIZATION Creates/recreates a @c domAny rooted doc. */
	inline void _anyDoc(daeDocRoot<domAny> &o, const daeName &QName, const daeURI &URI, daeIOPlugin *I)
	{ 
		o = newDoc(URI,I); daeDocumentRef docu = o->getDocument();
		daeDOM *DOM = const_cast<daeDOM*>(getDOM());
		if(docu!=nullptr&&o==DAE_OK) (docu->getRoot()=domAnyRef(DOM))->setElementName(QName);
	}

	template<class ROOT>
	/**
	 * Creates/recreates a new doc by opening @a URI.
	 * @tparam ROOT validates the document at @a URI.
	 * When @a ROOT is not a generated element based class, it has three other
	 * forms: Where ROOT is @c void, ROOT and @a I if @c nullptr are forwarded
	 * to @c getDOM()->getPlatform().openURI().	 
	 * Where ROOT is @c void*, the same, except @c daeURI::setAllowsAny() will
	 * be added to @a URI. This is intended to complement temporary parameters.
	 * Where ROOT is @c domAny, @a URI is created purely of @c domAny elements.
	 * @see @c daePlatform::openURI().
	 */
	inline daeDocRoot<ROOT> openDoc(const daeURI &URI, daeIOPlugin *I=nullptr)
	{
		daeDocRoot<ROOT> o; _read(o,daeIORequest(this,nullptr,&URI,&URI),I); return o;
	}

	template<class ROOT> 
	/**LEGACY, WARNING
	 * Creates/recreates a new document, filled with plugin processed string text.
	 * @warning Nothing requires @a I interpret @a string as a document in memory.
	 * The string doesn't have be 0-terminated. The built-in (old) TinyXML loader
	 * has been rewritten to not depend on a 0. But if the string is bad it might
	 * read past the end. The LibXML plugin is a vast improvement but still lousy.
	 * @see openDoc() Doxygentation.
	 */	
	inline daeDocRoot<ROOT> openDocFromMemory(const daeURI &URI, const daeHashString &string, daeIOPlugin *I=nullptr)
	{
		daeDocRoot<ROOT> o; _read(o,daeIORequest(this,string,&URI),I); return o;
	}

	/** 
	 * Writes doc where @a localURI is lexically identical to remote URI.
	 */
	inline daeOK writeDoc(const daeURI &localURI, daeIOPlugin *O=nullptr)const
	{
		const_daeDocRef doc; getDoc(localURI,doc);
		if(doc==nullptr)
		return DAE_ERR_DOCUMENT_DOES_NOT_EXIST; return doc->write(O);
	}
	/**
	 * Writes doc of @a localURI to @a remoteURI.
	 */
	inline daeOK writeDocTo(const daeURI &localURI, const daeURI &remoteURI, daeIOPlugin *O=nullptr)const
	{
		const_daeDocRef doc; getDoc(localURI,doc);		
		if(doc==nullptr)
		return DAE_ERR_DOCUMENT_DOES_NOT_EXIST; return doc->writeTo(remoteURI,O);
	}
	
	/**
	 * Closes the doc, unloading all memory used by the document-or-archive.
	 * @return Returns DAE_OK if the document is closed. 
	 * @note Permission is gotten from @c daePlatform::closeURI().
	 * @see daeDoc::close() Doxygentation for how to circument thsi procedure.
	 */
	inline daeOK closeDoc(const daeURI &URI)
	{
		daeDocRef doc; getDoc(URI,doc);
		if(doc==nullptr)
		return DAE_ERR_DOCUMENT_DOES_NOT_EXIST; return doc->close();
	}
	
	/** 
	 * @return Returns the @c daeDoc array. 
	 */
	NOALIAS_LINKAGE const daeArray<daeDocRef> &getDocs()
	SNIPPET( return _docs; )
	/**CONST-PROPOGATING-FORM
	 * @return Returns the @c daeDoc array. 
	 */
	inline const daeArray<const_daeDocRef> &getDocs()const
	{
		return (daeArray<const_daeDocRef>&)const_cast<daeArchive*>(this)->getDocs();
	}

	/**
	 * @return Returns the total number of documents. 
	 */
	inline size_t getDocCount()const{ return getDocs().getCount(); }

	/** 
	 * @return Returns the @a i'th open document. 
	 * @note There is no association. This is strictly enumeration.
	 */
	inline const daeDocRef &getDoc(size_t i){ return getDocs()[i]; }
	/**CONST-PROPOGATING-FORM
	 * @return Returns the @a i'th open document.
	 * @note There is no association. This is strictly enumeration.
	 */
	inline const const_daeDocRef &getDoc(size_t i)const{ return getDocs()[i]; }
	/**
	 * Gets a doc matching @a URI, or @c nullptr.
	 */
	inline daeDocRef &getDoc(const daeURI &URI, daeDocRef &matchingDoc)
	{
		return URI.docLookup2(*this,matchingDoc);
	}
	/**CONST-PROPOGATING-FORM
	 * Gets a doc matching @a URI, or @c nullptr.
	 */
	inline const_daeDocRef &getDoc(const daeURI &URI, const_daeDocRef &matchingDoc)const
	{
		return URI.docLookup2(*this,matchingDoc);
	}	
	/**LEGACY
	 * Gets a doc matching @a URI, or @c nullptr.
	 */
	inline daeDocRef getDoc(const daeURI &URI)
	{
		daeDocRef matchingDoc; return URI.docLookup2(*this,matchingDoc);
	}			
	/**LEGACY, CONST-PROPOGATING-FORM
	 * Gets a doc matching @a URI, or @c nullptr.
	 */
	inline const_daeDocRef getDoc(const daeURI &URI)const
	{
		const_daeDocRef matchingDoc; return URI.docLookup2(*this,matchingDoc);
	}
	template<class S, class T>
	/**LEGACY
	 * Gets a @c daeDocRoot compatible with @a S.
	 */
	inline daeDocRoot<S> getDoc(const T &i_or_URI)
	{
		return getDoc(i_or_URI);
	}			
	template<class S, class T>
	/**LEGACY, CONST-PROPOGATING-FORM
	 * Gets a @c daeDocRoot compatible with @a S.
	 * @note @c daeDocRoot wasn't designed with @c const types in mind.
	 */
	inline daeDocRoot<const typename S::__COLLADA__T> getDoc(const T &i_or_URI)const
	{
		return getDoc(i_or_URI);
	}

	/**WARNING, CONST-ONLY
	 * Gets the base URI used for resolving relative URI references. 
	 * @return Returns the same @c daeURI& as @c daeDoc::getDocURI().
	 *
	 * @warning Because archives are also files, this URI doesn't have
	 * a slash (/) on the end, but @c true==daeURI::getIsDirectoryLike()
	 * so that when used as a base, a slash will be inserted.
	 */
	inline const daeURI &getBaseURI()const{ return _uri; }

COLLADA_(public) //ZAE	
	/**
	 * ZAE archives use this interface. 
	 *
	 * @c daeDOM get a dummy/common atlas. If @c daeImage objects 
	 * are to be associated with the DOM (for some reason) a new
	 * atlas should be assigned to @c _getAlas().
	 */
	inline daeAtlas &getAtlas()const
	{
		return *const_cast<daeArchive*>(this)->_getAtlas(); 
	}
	/**
	 * Use this to assign a @c daeAtlas. The archives can share an
	 * atlas.
	 *
	 * @note @c daeArchive is an internal structure, so the atlases
	 * must be assigned after the factory creates the archive, even
	 * though they're practically synonymous with one another.
	 */
	NOALIAS_LINKAGE daeAtlasRef &_getAtlas()
	SNIPPET( return _atlas; )

	/**
	 * Convenience function. DOM objects don't have I/O controllers.
	 */
	inline daeIOController &getIOController()const
	{
		if(!_isDOM()) return getAtlas();
		else return _getPlatform(*(daeDOM*)this);
	}

	/**WARNING
	 * Sets the index document for this archive. For ZAE this can
	 * be the document indicated by the <dae_root> element inside
	 * the manifest.xml file. 
	 * @see @c daeDoc::getDocument().
	 *
	 * @warning I/O plugins may set this under certain conditions.
	 * Most of the time however, there's no way to know what this
	 * should return; and so if user code relies on it, it should
	 * first see to it that it is always set correctly. (Consider
	 * that the library cannot constantly monitor ZAE archives to
	 * see if dae_root has been opened, since manifest.xml itself
	 * may not be opened either. Users must decide how to do it.)
	 */
	inline daeOK setDocument(const daeDocument *d)
	{
		//Maybe this should be unrestricted? but the DOM's must match!
		//if(d!=nullptr&&d->getDOM()!=getDOM()) return DAE_ERR_INVALID_CALL;
		if(d!=nullptr&&!d->inArchive(this)) return DAE_ERR_INVALID_CALL;
		_link = const_cast<daeDocument*>(d); return DAE_OK;
	}

COLLADA_(protected) //INTERNAL	

	/** Type received by @c _setDeleter(). */
	typedef void(*_deleter_f)(const DAEP::Object*);
	/** Implements @c daeDOM::setDeleter(). */
	LINKAGE void _setDeleter(_deleter_f=nullptr);

	/**CIRCULAR-DEPENDENCY 
	 * This rightly belongs in @c daeDOM; @c _read() calls it. */
	NOALIAS_LINKAGE static daePlatform &_getPlatform(const daeDOM &DOM);
	
#ifdef BUILDING_COLLADA_DOM

COLLADA_(protected) //INVISIBLE
		/**
		 * Constructor & Virtual Destructor
		 */
		daeArchive(daeDOM&); virtual ~daeArchive(){}

		/**PURE-OVERRIDE */
		virtual void __daeDoc__v1__atomize();

		/** Set with @c daeDOM::setDeleter(). */
		_deleter_f _deleter;
		
		/**ZAE
		 * @c daeZAEPlugin sets this to an internal
		 * @c daeZAE atlas.
		 * @see daeAtlas.h and daeZAEUncompressHandler.cpp.
		 */
		daeAtlasRef _atlas;

		/**
		 * Pre-2.5 docs belonged to @c daeDatabase.
		 */
		daeArray<daeDocRef> _docs;

		/**
		 * Removes docs with only a single smart-ref.
		 */
		void _compactDocs(size_t *before=nullptr, size_t *after=nullptr);

COLLADA_(public) //INVISIBLE

		/**EXPERIMENTAL
		 * @c daeURI::docLookup() sets this to its lower-bound.
		 */
		mutable size_t _whatsupDoc;
		/**
		 * Inserts @a doc at @c _docs[_whatsupDoc]. 
		 * (@a doc is technically moved from its existing archive,
		 * and into @c this archive.)
		 */
		void _whatsupDocInsert(daeDoc *doc);				
		/**
		 * Moves @a doc temporarily into @a daeDOM::_closedDocs.
		 * This is to keep a changing URI from spoiling lookups.
		 */
		inline void _movingDoc(daeDoc *doc)const
		{
			const_cast<daeArchive*>(this)->_removeDoc(doc,nullptr); 
		}
		/**
		 * Moves @a doc permanently into @a daeDOM::_closedDocs;
		 * After which it's all but "destructed." Eg. ~daeDoc().
		 */
		void _closedDoc(daeDoc *doc, daeDoc *replacement=nullptr);

COLLADA_(private) //INVISIBLE

		/**PRIVATE SUBROUTINE
		 * Takes @a doc out of @c _docs, and nothing more.
		 * @param _ is used by @c _closedDoc to pass the replacement.
		 * @c _whatsupDoc is used as a hint.
		 */
		void _uprootDoc(daeDoc *doc, daeDoc *uprooted_replacement);
		/**PRIVATE SUBROUTINE 
		 * Implements _movingDoc() while protecting @a uprooted_replacement. 
		 */
		daeDOM *_removeDoc(daeDoc *doc, daeDoc *uprooted_replacement);		

#endif //BUILDING_COLLADA_DOM	
};

/**
 * The @c daeDOM class is the core interface via which to interact with the DOM.
 *
 * Post-2.5 it is based on the new @c daeArchive class; only because it requires
 * so much of the same functionality. Conceptually it is more like a virtual or a
 * pseudo-archive--Although it could be desirable to put it into a special archive
 * mode one day. (As a possible feature that simulates a completely-closed system.)
 */
class daeDOM : public daeArchive
{	
	template<class> friend class daeSmartRef;			

COLLADA_(public) //daeSmartRef<T> T factories	
	/**
	 * Adds an archive to the database. 
	 */
	NOALIAS_LINKAGE daeArchive *_addArchive();
	/** 
	 * Adds a document to the database. 
	 */
	NOALIAS_LINKAGE daeDocument *_addDocument();
	/** 
	 * Adds a generic object to the database.
	 */
	NOALIAS_LINKAGE daeObject *_addObject(size_t);
	/**
	 * Adds an orphan element to the database. 
	 */
	NOALIAS_LINKAGE daeElement *_addElement(daeMeta&);
	/**
	 * Implements @c daeSmartRef::daeSmartRef(daeDOM&). 
	 */
	template<class T> inline T *_add()const
	{	
		assert(this!=nullptr);
		return const_cast<daeDOM*>(this)->_add2<T>((T*)nullptr);
	}	
	/**OVERLOAD Adds a generic object to the database. */
	template<class T> inline T *_add2(...)
	{
		_add2_concrete_CTC<T,0>(dae((T*)nullptr));
		T *obj(new(_addObject(sizeof(T)))T(*this));
		obj->__DAEP__Object__unembed(1); return obj;
	}
	/**CTC: @c daeDOM should not add a @c daeDOM to itself. */	
	template<class,int> inline void _add2_concrete_CTC(daeDOM*)
	{
		daeCTC<0>("DOM cannot add a DOM to itself.");
	}
	/**CTC @c DAEP::Element & @c daeElement are abstract. */
	template<class,int> inline void _add2_concrete_CTC(daeElement*)
	{
		daeCTC<0>("Elements must be a concrete type.");
	}		
	/**ENABLED: Almost forgot this one! */	
	template<class T, int I> inline void _add2_concrete_CTC(daeObject*)
	{
		if(I==0) _add2_concrete_CTC<T,1>((T*)nullptr); 
	}
	/**TEMPLATE-SPECIALIZATION Adds an archive to the database. */
	template<class> inline daeArchive *_add2(daeArchive*)
	{
		return _addArchive();
	}
	/**TEMPLATE-SPECIALIZATION Adds a document to the database. */
	template<class> inline daeDocument *_add2(daeDocument*)
	{
		return _addDocument();
	}
	/**OVERLOAD Adds an orphan, concrete element to the database. */
	template<class T> inline T *_add2(typename T::__COLLADA__Element*)
	{
		return (T*)_addElement(daeGetMeta<T>());
	}

COLLADA_(public) //OPERATORS

	COLLADA_DOM_OBJECT_OPERATORS(daeDOM)

COLLADA_(public) //CONSTRUCTORS
	/**STATIC
	 * Sets the global platform so code can ignore its part in
	 * the constructor. The global platform is process-wide, so
	 * don't set this if your code is part of a software library.
	 */
	LINKAGE static void setGlobalPlatform(daePlatform *OS)
	SNIPPET( daeDOM::_globalPlatform = OS; )
	/**STATIC
	 * Gets the global platform. If it's gloabal it's everyone's.
	 */
	NOALIAS_LINKAGE static daePlatform *getGlobalPlatform()
	SNIPPET( return daeDOM::_globalPlatform; )
	
	NOALIAS_LINKAGE 
	/**
	 * Allocates a DOM with @c new. This disables @c setDeleter().
	 */
	static daeDOM *__daeDOM__new(daeDatabase_base *DB=nullptr, daePlatform *OS=nullptr);
	/**
	 * Default Constructor
	 *
	 * There can't be more than one constructor, lest they all be
	 * exported/implemented separately. (Inline constructors can't
	 * be used, and historically there'd never been a factory API.)
	 *
	 * @param DB If @c nullptr, @c daePlatform::attachDB() is called.
	 * If still @c nullptr, a private, built-in database is provided.
	 * (@c daePlatform::getLegacyProfile() may be used to select it.)
	 * @param OS If @c nullptr @c getGlobalPlatform() is called upon.
	 * If there's no global platform, a NON-WORKING platform is used.
	 * (It'd sure be nice to have a default platform; but difficult.)
	 *
	 * @param OK Is designed to guarantee the process-share slot was
	 * established before the user code calls @c openDoc() via a URI.
	 * Typically this would be the first thing done, and a @c daeURI 
	 * is an object that needs to have the slot assigned to its tags.
	 * @c DOM_grant_process_share() is NOT THREAD-SAFE at the moment.
	 * If @c OK is somehow not @c DAE_OK then @c OS will not be used.
	 */
	daeDOM(daeDatabase_base *DB=nullptr, daePlatform *OS=nullptr)
	#ifdef BUILDING_COLLADA_DOM
	;
	#else //This setup is for Visual Studio, since it doesn't call the destructor of automatic objects.
	{
		__daeDOM__construct(*this,DB,OS);
	}
	/**
	 * Virtual Destructor for Visual Studio.
	 */
	virtual ~daeDOM()
	{ 
		__daeDOM__destruct(*this); assert(_uri.empty()&&isUnparentedObject());
	}
	#endif
	/**
	 * Note this is not so bad, since it should be possible to set up 
	 * alternative constructors like this, without additional exports.
	 */
	LINKAGE static void __daeDOM__construct(daeDOM &_this, daeDatabase_base *DB, daePlatform *OS)
	SNIPPET( new(&_this) daeDOM(DB,OS); )
	LINKAGE static void __daeDOM__destruct(daeDOM &_this)
	SNIPPET( _this.daeDOM::~daeDOM(); )	

	/**
	 * Sets an API used to delete @c this if the ref-count is brought
	 * to 0. This can only be done once. If set to @c nullptr nothing
	 * changes deletion-wise, but future calls are made to trigger an
	 * @c assert() and or error-handler output.
	 *
	 * @param deleter receives the @c daeDOM intact and must call the
	 * @c daeDOM::~daeDOM() directly or indirectly. The module having
	 * the definition of @a deleter cannot be unloaded until deletion.
	 * The intended rationale for using @c setDeleter() is to receive
	 * notice of the DOM's demise, in order to take action, or delete
	 * a larger super-object that is containing the @c this @c daeDOM.
	 */
	inline void setDeleter(void(*deleter)(daeDOM*)=nullptr)
	{
		_setDeleter((daeArchive::_deleter_f)deleter);
	}

COLLADA_(public) //ACCESSORS & MUTATORS
	/**
	 * Gets the database, bound to this DOM, for ever more. 
	 * @note Databases may be bound to more than one DOM at a time.
	 * If the DOM "leaves scope," the database may transfer its contents to
	 * a temporary DOM. In this case, the database remains saddled with the objects.
	 */
	NOALIAS_LINKAGE daeDatabase &getDatabase()const
	SNIPPET( return *_database; )
	
	/**CIRCULAR-DEPENDENCY
	 * Gets the OS-like platform, bound to this DOM, for ever more. 
	 */
	inline daePlatform &getPlatform()const{ return _getPlatform(*this); }
								  
	/**OVERRIDE
	 * This overrides @c daeArchive::getBaseURI() since a DOM does
	 * not have a base--or it is always empty--or it is as long as
	 * it represents the entire domain of an Internet like network.
	 * @see getDefaultBaseURI().
	 */
	inline void getBaseURI()const{}

	/**REPLACES @c daeURI &getBaseURI().
	 * Gets the base URI used for resolving relative URI references. 
	 * @remarks This is the "current working directory" in URI form.
	 */
	NOALIAS_LINKAGE daeURI &getDefaultBaseURI()
	SNIPPET( return _closedDocs._uri; )
	/**CONST-PROPOGATING-FORM
	 * REPLACES @c daeURI &getBaseURI().
	 * Gets the base URI used for resolving relative URI references. 
	 * @remarks This is the "current working directory" in URI form. 
	 */
	inline const daeURI &getDefaultBaseURI()const
	{
		return const_cast<daeDOM*>(this)->getDefaultBaseURI(); 
	}
	
	/**OPTIMIZATION
	 * This is optimizing @c daeStringRef's prototype-constructor.
	 * @c _uri will probably stay empty for the foreseeable future.
	 *
	 * Gets a DOM-wide special empty URI. That is a blank, zero-sized, 
	 * -URI, that is used in special circumstances, such as an ultimate
	 * base URI. (The default-base URI requires a well-defined base also.)
	 * HISTORICAL NOTES
	 * In @c daeDoc::_doOperation() there is a bit that detects attempts to
	 * change this URI, and prevents them. It is initially assigned to docs.
	 */										
	inline const daeURI &getEmptyURI()const{ return _uri; }	

COLLADA_(public) //LEGACY ACCESSORS & MUTATORS

	/**WARNING, LEGACY
	 * @return Returns the list of ref-resolvers. 
	 * You can modify the list to add new resolvers.
	 * @warning BE CAREFUL USING @c new TO INSERT A NEW
	 * RESOLVER WITHOUT USING @c __DAEP__Object__unembed().
	 * @c The @C daeSmartRef factory APIs can be used instead.
	 * Just know that they always use the database's memory pool.
	 */
	inline daeRefResolverList &getRefResolvers()
	{
		return (daeRefResolverList&)_getRefResolvers();
	}	
	/**LEGACY, CONST-PROPOGATING-FORM
	 * @return Returns the list of immutable ref-resolvers. 
	 */
	inline const daeRefResolverList &getRefResolvers()const
	{
		return const_cast<daeDOM*>(this)->getRefResolvers();
	}
	/**INSURANCE Implements @c getRefResolvers(). */
	NOALIAS_LINKAGE daeContainerObject<> &_getRefResolvers()
	SNIPPET( return *_refResolvers._plain_vanilla_this(); )

	 //EUROPEAN 8-BIT ASCII BUSINESS?
	//The Latin encoding stuff is moved to daeLibXMLPlugin.
	//Note, it doesn't have to do with character-sets, but
	//rather how the in-memory documents are to be encoded.
	//The library doesn't care; or it shouldn't. Users are
	//encouraged to use plugins that will meet their needs.
	#ifndef COLLADA_NODEPRECATED	
	COLLADA_DEPRECATED("daePlatform::setLegacy")
	static void setGlobalCharEncoding(void);
	COLLADA_DEPRECATED("daeLibXMLPlugin::option_to_use_codec_Latin1")
	void setCharEncoding(void);	
	#endif

COLLADA_(public) //PUBLIC METHODS		
	/**WARNING
	 * Releases closed docs having no outstanding reference holders.
	 *
	 * @warning If thisnote If @c this DOM is closed, this API will not return @c true.
	 * (Or if it does, it means @c this is no more, and 
	 *
	 * @param before Optional counter to add to for each doc considered.
	 * @param after Optional counter to add to for each doc not released.
	 * @return Returns @c _closedDocs.empty().
	 */
	LINKAGE bool clear_closedDocs(size_t *before=nullptr, size_t *after=nullptr)
	SNIPPET( _closedDocs._compactDocs(before,after); return _closedDocs._docs.empty(); )

	/**
	 * This is recommended to remove dependencies on schemas without hard
	 * closing a @c daeDOM, which is irreversible. This allows the module
	 * hosting the schema to be unloaded and vice versa; consider process
	 * termination.
	 * @note This would be "clear()" but for @c getRefResolvers().clear().
	 */
	inline daeOK clear_of_content()
	{
		const daeArray<daeDocRef> &docs = getDocs();
		while(!docs.empty())
		{
			daeOK OK = docs.back()->close(); if(OK!=DAE_OK) return OK;
		}
		return !clear_closedDocs()?DAE_ERROR:DAE_OK;
	}

	enum{ __size_on_client_stack=256*sizeof(void*) };

#ifndef BUILDING_COLLADA_DOM

	char __client_padding[__size_on_client_stack-sizeof(daeArchive)];

#else

COLLADA_(public) //INVISIBLE		
		/**
		 * Virtual Destructor 
		 */
		virtual ~daeDOM();

COLLADA_(private) //INVISIBLE		
		
		/**PURE-OVERRIDE */
		virtual DAEP::Model &__DAEP__Object__v1__model()const;
		/**OVERRIDE */
		virtual void __daeDoc__v1__atomize();

		friend class daeDoc;				
		friend class daeArchive;
		friend class daeURI_base;
		//SUB-OBJECT
		/**ORDER-OF-INITIALIZATION MATTERS 
		 * Archive housing closed documents.
		 * @note @c _closedDocs._uri is housing the working-directory,
		 * -while @c this->_uri is empty, reflecting an archive model.
		 * The plan is to have two DOM-modes, and to reverse the URIs
		 * in the other mode.
		 *
		 * @c _closedDocs is not sorted, and is shouldn't be accessed.
		 * It is used as a temporary floating-archive for docs on the
		 * move, between URLs, or prior to having a URL. IOW, the doc
		 * may not necessarily be closed.
		 *
		 * When an archive is closed, its own docs stay in the closed
		 * archive. In this way the closed-docs are like a second DOM.
		 * (It's required to keep the docs until their references are
		 * let go of. Unfortunately being corralled means referencing
		 * them. They could be left to the ether, but still, floating
		 * docs and @c daeDoc::getArchive() require a local archive.)
		 */
		daeArchive _closedDocs;					

		friend class daeStringRef;
		friend class daeMetaElement;
		/** 
		 * The database. Could be reference, but must be modelable. 
		 */
		daeDatabase_base *_database; 		
		/**
		 * Private data pointer belonging to the database. 
		 */
		mutable void *_databaseRejoinder; 
		/**
		 * Call @c daePlatform::detachDB() or @c delete the database. 
		 */
		bool _detachDatabase, _deleteDatabase;		
		/**
		 * The platform. Can be dummy platform if not provided. 
		 */
		daePlatform *_platform;
		/** 
		 * The system-wide, user-supplied, default platform. 
		 */
		static daePlatform *_globalPlatform;		
		/**
		 * Lets clients call @c ~daeDOM() manually. 
		 * @see @c daeDOM_outstanding
		 */
		bool _destructed;

		//SUB-OBJECT
		/** List of @c daeRef "resolvers." */
		daeRefResolverList _refResolvers;

		/** Implements @c daeDoc::_write() where @c this is a @c daeDOM*. */
		daeOK _write_this_DOM(const daeURI&,daeIOPlugin*)const;

#endif //BUILDING_COLLADA_DOM	
};

#include "./LINKAGE.HPP" //#undef LINKAGE
		   
//---.
}//<-'

#endif //__COLLADA_DOM__DAE_H__
/*C1071*/
