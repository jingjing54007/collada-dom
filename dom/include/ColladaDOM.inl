/*
 * Copyright 2006 Sony Computer Entertainment Inc.
 *
 * Licensed under the MIT Open Source License, for details please see license.txt or the website
 * http://www.opensource.org/licenses/mit-license.php
 *
 */
#ifndef __COLLADA_DOM_INL__
#define __COLLADA_DOM_INL__

#include "WARNING.HPP" //push

//This includes the entirety of the library.
#include "dae.h"
#include "dae/daeMetaSchema.h"
#include "dae/daeErrorHandler.h"
#include "dae/daeIOPluginCommon.h"
#include "dae/daeStandardURIResolver.h"
//This is internal, but useful for I/0 code.
#include "dae/daeRAII.hpp"

//Miscellaneous and circularly defined APIs.
COLLADA_(namespace)
{//-.
//<-'
		
template<class S, class T>
/**WARNING, LEGACY
 * Checks if an abstract object's type matches @a T.
 *
 * @remark This was a 2.4 API for converting pointers
 * returned by some APIs that did not know about their
 * return types. 
 *
 * In general it's too clunky and it's no longer really
 * required. It was never the less sometimes used. Until
 * it was largely supplanted by @c daeElement::a().
 * @see @c daeElement::a() also @c daeElement::an().
 *
 * @warning Currently this check is based on the metadata
 * object's pointer. It was ID based, but there is not any 
 * way to tell which schema the ID belongs. If the pointers
 * were generated by different modules, the objects might be
 * binary-compatible but still fail to cast.
 */
inline typename daeConstOf
<T,typename S::__COLLADA__T>::type *daeSafeCast(T *e)
{
	const daeElement *upcast = dae(*e);
	if(e!=nullptr) if(daeUnsafe<S>(upcast))
	{
	#ifndef COLLADA_quiet_daeSafeCast
	assert(!"daeSafeCast() failed."); //2.5: Alert the user?
	#endif
	}
	else return (S*)e; return nullptr;
}
/**TEMPLATE-SPECIALIZATION Implements @c daeUnsafe(). */
template<class S> inline bool _daeUnsafe2(const daeElement *e)
{	
	#ifdef COLLADA_dynamic_daeSafeCast
	return dynamic_cast<const DAEP::Elemental<S>*>(e)==nullptr;
	#else
	return e==nullptr||e->getMeta()!=daeGetMeta<S>();
	#endif
}
/**TEMPLATE-SPECIALIZATION Implements @c daeUnsafe(). */
template<> inline bool _daeUnsafe2<domAny>(const daeElement *e)
{
	return e==nullptr||!e->_isAny();
}
/**TEMPLATE-SPECIALIZATION Implements @c daeUnsafe(). */
template<> inline bool _daeUnsafe2<daeObject>(const daeElement*){ return false; }
/**TEMPLATE-SPECIALIZATION Implements @c daeUnsafe(). */
template<> inline bool _daeUnsafe2<daeElement>(const daeElement*){ return false; }
/**TEMPLATE-SPECIALIZATION Implements @c daeUnsafe(). */
template<> inline bool _daeUnsafe2<DAEP::Element>(const daeElement*){ return false; }
/**TEMPLATE-SPECIALIZATION Implements @c daeSafeCast(). */
template<class S> inline bool daeUnsafe(const daeElement *e)
{
	return _daeUnsafe2<typename daeConstOf<int,typename S::__COLLADA__T>::type>(e);
}
/**
 * Extract the metadata by constructing an uninitialized "elemental"
 * in order to use its virtual-method-pointer. In theory optimizers
 * can elide construction of the object.
 *
 * It's debateable whether having this procedure as a virtual method
 * is for the best. It makes more sense with objects than elements. 
 * Elements are objects. When this was worked on initially, it wasn't
 * obvious that static inline methods could serve the same purpose. 
 * It would've been simple to do a test, but "I" had so much doubt that
 * I didn't bother. (I can't recall what my biases were...)
 *
 * It's trivial to have DAEP Elemental declare a static inline method, 
 * and let the virtual method wrap around that. It would be the best of
 * both worlds, in case there's some use to having the virtual methods,
 * -or just because elements should be valid objects.
 */
template<class T> inline const daeModel &daeGetModel()
{
	daeElement *nonconst = dae((typename T::__COLLADA__T*)nullptr); (void)nonconst;
	return DAEP::Elemental<typename T::__COLLADA__T>(DAEP::VPTR).__DAEP__Object__v1__model(); 
}
/**
 * Statically extract the @c daeMetaElement pointer. 
 * @tparam T must be based on @c daeElemental or @c DAEP::Elemental, or 
 * this template will not compile. This excludes @c domAny.
 */
template<class T> inline daeMeta &daeGetMeta()
{
	//Don't use daeOpaque here as long as daeModel converts to daeMeta*.
	return daeOpaque(&daeGetModel<typename T::__COLLADA__T>())[sizeof(typename T::__COLLADA__T)];
}
/**TEMPLATE-SPECIALIZATION
 * Since @c domAny is shared, its layout isn't known to clients.
 */
template<> inline daeMeta &daeGetMeta<domAny>()
{
	//Reminder: This lets "math:math" default to domAny.
	return daeGetModel<domAny>();
}
		
/**CIRCULAR-DEPENDENCY
 * @warning A @c daeDOM is never stored in a database.
 * @return Returns the @c daeDatabase storing the object, or
 * -returns @c nullptr if the object is not database stored.
 * @see ColladaDOM.inl header's definition.
 */
inline daeDatabase *daeObject::_getDBase()const
{
	return _isData()?&getDOM()->getDatabase():nullptr; 
}
/**LEGACY, CIRCULAR-DEPENDENCY
* Accessor to get the database associated with this document.
* @return Returns the database associated with this document.
*/
inline daeDatabase &daeDoc::getDatabase()const{ return getDOM()->getDatabase(); }
/**CIRCULAR-DEPENDENCY
 * This is newly added in case it's decided to store a copy of @c daeDOM::_database in
 * every element, alongside a copy of the @c daeMetaElement pointer. They are constant
 * for the entirety of the element's life.
 */
inline daeDatabase &daeElement::getDatabase()const{ return getDOM()->getDatabase(); }

template<>
/**KISS, CIRCULAR-DEPENDENCY 
 * Implements @c daeArray<daeContent>::clear().
 * Perhaps "__COLLADA__clear" is in order? Contents-arrays are special.
 * @see ColladaDOM.inl header's definition.
 */
inline void daeArray<daeContent>::_clear2(daeContent*)
{
	//If getObject() is nullptr it's likely to be @c XS::Choice::_solve().
	//In that case, clear() is not supported; call _clear2<void>() directly.
	assert(_au->_offset!=0); ((daeElement*)getObject())->__clear(*this); 
}
template<>
/** KISS, CIRCULAR-DEPENDENCY
 * Implements @c daeArray<daeContent>::grow(). 
 * @c __COLLADA__move() was going to be used, but when 
 * @c daeCursor was made to be an iterator, it became necessary to adjust it.
 * @see ColladaDOM_3.inl header's implementation.
 */
inline void daeArray<daeContent>::_grow2(size_t minCapacity,daeContent*)
{
	//If getObject() is nullptr it's likely to be @c XS::Choice::_solve().
	//In that case, grow() is not supported; call _grow2<void>() directly.
	assert(_au->_offset!=0); 
	//>= is used to include the 0-terminator. __grow() adds 1 to minCapcity.
	if(minCapacity>=getCapacity()) ((daeElement*)getObject())->__grow(*this,minCapacity); 
}

/**LEGACY, CIRCULAR DEPENDENCY
 * Goes beyond @c get(), returning either an xs:list dataset, 
 * -or, an individual unit of data. (This implements SIDREF.)
 * @see ColladaDOM.inl header's definition.
 */
inline daeOK daeRef::get(daeRefRequest &req)const
{	
	const_daeDOMRef dom(req.object!=nullptr?req.object->getDOM():getDOM());
	if(nullptr==dom)
	return DAE_ERR_INVALID_CALL; return dom->getRefResolvers().resolve(*this,req);
}

/////////////////////////////////////////////////////////////////
//This section is for ColladaDOM 3 style enum structs. Defining//
//these operators in the template, with @c friend, dramatically//
//bloats MSVC2015 precompiled headers. Perhaps it would be best//
//to move the non = assignment operators into the global scope?//
/////////////////////////////////////////////////////////////////

//Defining this may reduce the size of precompiled header files.
//It seems to help Visual Studio dramatically just by virtue of
//having them as global operators, versus defined in a template.
#ifndef COLLADA_DOM_GLOBAL_ASSIGNMENT_OPERATORS_NOT_INCLUDED
#define __ DAEP::Value<ID,T,CC,PtoM>
#define _(bop) \
template<int ID, class T, class CC, typename CC::_ PtoM, class S>\
inline __ &operator bop(__ &lv, const S &rv)\
{\
	typedef typename __::underlying_type ut;\
	struct _{ static void f(ut &lv, const S &rv){ lv bop rv; } };\
	DAEP::InnerChange<__,S/*,_::f*/> cn(lv,_::f,rv); return lv;\
}
/** Implements @c DAEP::Concern based change-notice. */
_(-=)_(+=)_(/=)_(%=)_(*=)_(<<=)_(>>=)_(&=)_(|=)_(^=)
#undef _
#define _(uop) \
template<int ID, class T, class CC, typename CC::_ PtoM>\
inline __ &operator uop(__ &lv)\
{\
	typedef typename __::underlying_type ut;\
	struct _{ static void f(ut &lv, const int &rv){ lv uop; } };\
	DAEP::InnerChange<__,int/*,_::f*/> cn(lv,_::f,int()); return lv;\
}\
template<int ID, class T, class CC, typename CC::_ PtoM>\
inline typename __::underlying_type operator uop(__ &lv,int)\
{\
	typename __::underlying_type o = lv; uop lv; return o;\
}
/**WARNING
 * Implements @c DAEP::Concern based change-notice. 
 * @warning Postfix ++ and -- return a copy of the
 * original value, and apply the prefix equivalent.
 */
_(++)_(--)
#undef _	
#undef __
#endif //COLLADA_DOM_GLOBAL_ASSIGNMENT_OPERATORS_NOT_INCLUDED

template<int ID, class T, class CC, typename CC::_ PtoM, class S>
/** Nominal == support for ColladaDOM 3 style enum structs. */
bool operator==(const DAEP::Value<ID,T,CC,PtoM> &a, const S &b)
{
	return *a.operator->()==b;
}
template<int ID, class T, class CC, typename CC::_ PtoM, class S>
/** Nominal != support for ColladaDOM 3 style enum structs. */
bool operator!=(const DAEP::Value<ID,T,CC,PtoM> &a, const S &b)
{
	return *a.operator->()!=b;
}
template<int ID, class T, class CC, typename CC::_ PtoM, class S>
/** Nominal == support for ColladaDOM 3 style enum structs. */
bool operator==(const S &a, const DAEP::Value<ID,T,CC,PtoM> &b)
{
	return a==*b.operator->();
}
template<int ID, class T, class CC, typename CC::_ PtoM, class S>
/** Nominal != support for ColladaDOM 3 style enum structs. */
bool operator!=(const S &a, const DAEP::Value<ID,T,CC,PtoM> &b)
{
	return a!=*b.operator->();
}
template<int ID,class T,class CC,typename CC::_ PtoM, int ID2,class T2,class CC2,typename CC::_ PtoM2>
/** C++ is kind of messed up in that it requires 6 overloads to not be ambiguous. */
bool operator==(const DAEP::Value<ID,T,CC,PtoM> &a, const DAEP::Value<ID2,T2,CC2,PtoM2> &b)
{
	return *a.operator->()==*b.operator->();
}
template<int ID,class T,class CC,typename CC::_ PtoM, int ID2,class T2,class CC2,typename CC::_ PtoM2>
/** C++ is kind of messed up in that it requires 6 overloads to not be ambiguous. */
bool operator!=(const DAEP::Value<ID,T,CC,PtoM> &a, const DAEP::Value<ID2,T2,CC2,PtoM2> &b)
{
	return *a.operator->()!=*b.operator->();
}

template<class S, class T>
/** @c daeDocument uses this to convert strings into @c daeStringRef if need be. */
inline const daeStringRef daeBoundaryStringRef(const S &c, const T &str)
{
	return daeStringRef(c,str);
}
template<class S>
/** @c daeDocument uses this to convert strings into @c daeStringRef if need be. */
inline const daeStringRef &daeBoundaryStringRef(const S&, const daeStringRef &str)
{
	return str;
}
template<class S>
/** @c daeDocument uses this to convert strings into @c daeStringRef if need be. */
inline const daeStringRef &daeBoundaryStringRef(const S&, const daeTokenRef &str)
{
	return str; //The following check can be removed if there's a legit reason to.
	daeCTC<0>("daeTokenRef doesn't normally exist independently of DAEP::Value.");
}
template<class S, int ID, class T, class CC, typename CC::_ PtoM>
/** @c daeDocument uses this to convert strings into @c daeStringRef if need be. */
inline const daeStringRef &daeBoundaryStringRef(const S&, const DAEP::Value<ID,T,CC,PtoM> &str)
{
	return str;
}
template<class S>
/**EXPERIMENTAL
 * This @c void form is provided for anal retentives who believe their pointer
 * is a string-ref but for technical reasons it can't be directly passed along
 * to @c daeDocument::idLookup() without resorting to highly technical casting.
 * @c daeDocument uses this to convert strings into @c daeStringRef if need be. 
 */
inline const daeStringRef &daeBoundaryStringRef(const S &c, const void*const &str)
{
	return *(const daeStringRef*)&str; 
}

//---.
}//<-'

/** 
 * This macro extends WARNING.HPP. A GCC precompild header will lose the state.
 */
#ifdef COLLADA_DOM_WARNING_HPP
#undef __COLLADA_DOM__WARNING_HPP__
#else
#include "WARNING.HPP" //pop   
#endif

#endif //__COLLADA_DOM_INL__
/*C1071*/
