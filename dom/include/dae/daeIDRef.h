/*
 * Copyright 2006 Sony Computer Entertainment Inc.
 *
 * Licensed under the MIT Open Source License, for details please see license.txt or the website
 * http://www.opensource.org/licenses/mit-license.php
 *
 */

#ifndef __COLLADA_DOM__DAE_IDREF_H__
#define __COLLADA_DOM__DAE_IDREF_H__

#include "daeDocument.h" 
#include "daeRefResolver.h" 

COLLADA_(namespace)
{//-.
//<-'

template<int size_on_stack> class daeIDREF_size;
/**
 * Changes in 2.5:
 * ===============
 * The IDREF is a complex of both the ID and its containing document.
 * An IDREF without a document is meaningless! A document is required
 * to assign them IDs. (Its @c daeStringRef requires a string-table.)
 *
 * IDs are bound-to-documents; therefore, to be equal, both must be so.
 * @c daeIDREF is not generally useful, except as a nicety, where IDREFs are part of
 * a class based on @c daeElement--generated by the PHP databinding step. 
 * Prefer @c daeDocument's indexing-services over @c daeIDREF (which is what it uses.)
 *
 * Pre-2.5 notes:
 * ==============
 * The @c daeIDREF is a simple class designed to aid in the parsing and resolution of
 * ID references inside of COLLADA elements.
 * A @c daeIDREF is created for every IDREF data type in the COLLADA schema.
 * It also has the capability to attempt to resolve this reference
 * into a @c daeElement.  If a @c daeIDREF is stored within a @c daeElement it fills
 * in its container field to point to the containing element.
 *
 * The main API is the @c daeIDREF::resolveElement() will use a @c daeIDRefResolver
 * to search for the @c daeElement inside of a @c daeDatabase.
 */
typedef daeIDREF_size<120> daeIDREF;
typedef daeSmartRef<daeIDREF> daeIDREFRef;
typedef daeSmartRef<const daeIDREF> const_daeIDREFRef;
#ifndef COLLADA_NODEPRECATED
COLLADA_DEPRECATED("daeIDREF")
typedef daeIDREF daeIDRef;
#endif

template<class Type> 
/** 
 * This class is not for clients to use. 
 * @see @c daeIDREF_size, where it is the base-class.
 * @note ALL OF @c daeIDREF's VIRTUAL OVERRIDES BELONG IN THIS CLASS.
 */
class daeIDREF_base : public daeRef_support<daeIDREF_base<Type>>
{
	typedef daeRef_support<daeIDREF_base<Type>> _support;

COLLADA_(public) //daeRef methods

	/**PURE-OVERRIDE
	 * One of @c daeRefType, or negative if registered as a client type.
	 * @note @c Type is shadowing/overriding @c daeRef::getRefType().
	 */
	virtual int __daeRef__v1__type()const{ return Type::getRefType(); }

	/**PURE-OVERRIDE
	 * Gets this URI like reference's text--refreshed; cannot return @c nullptr.
	 */
	virtual daeString __daeRef__v1__text()const{ return _this()._refString.getString(); }

COLLADA_(public) //DAEP::Object methods

	/**PURE-OVERRIDE */
	virtual DAEP::Model &__DAEP__Object__v1__model()const
	{
		//daeRefString must be able to switch to dynamic-storage.		
		static DAEP::Model *om = nullptr; if(om!=nullptr) return *om;
		static daeAlloc<daeStringCP,0> t; daeModel &m =
		_support::getDefaultProcessShare().addModel<1>((Type*)this,"COLLADA::daeIDREF_base");				
		m.addFeature_variant<1>(this,*_this()._refString.getInternalStorage()
		,"VARIANT //daeRefString::_string").setAllocThunk_offset(t);
		m.addFeatureComplete();
		m.setObjectType(daeObjectType::REF); om = &m; return *om; 	
	}

COLLADA_(protected) //DATA MEMBER (or was)

	inline Type &_this()const{ return (Type&)*this; }
	
COLLADA_(private) //OBJECT MEMBERS

	struct _Flags
	{
		unsigned global:1; _Flags(){ (unsigned&)*this = 0; }
	};
	inline _Flags &_getFlags()const{ return (_Flags&)_support::_getClassTag(); } 

COLLADA_(public) //OPERATORS

	COLLADA_DOM_OBJECT_OPERATORS(Type)
	
	/**OPERATOR
	 * Assignment Operator
	 * @return Returns a reference to this object.
	 * 2.5: following @c daeURI::operator='s lead:
	 * The container is set, if not previously set.
	 * Regardless, the ID is set to @a cp::getIDREF().
	 */
	inline Type &operator=(const daeIDREF_base &cp)
	{
		if(_support::isUnparentedObject()&&DAE_OK!=_support::_reparent(cp.getParentObject()))
		{
			clear(); assert(0); //naughty			
		}
		else _this()._refString.setString(*this,cp.getRefText()); return (Type&)*this;
	} 	
	/** 
	 * String assignment @c operator=().
	 */
	inline Type &operator=(daeHashString cp){ _this()._refString.setString(*this,cp); return *this; }

	/**
	 * Cast to any @c daeIDREF_size, as the @c size_on_stack parameter is irrelevant.
	 */
	inline operator Type&(){ return static_cast<Type&>(*this); }
	/**CONST-FORM
	 * Cast to any @c daeIDREF_size, as the @c size_on_stack parameter is irrelevant.
	 */
	inline operator const Type&()const{ return static_cast<const Type&>(*this); }

COLLADA_(public) //daeRef_support traits

	/** Implements @c operator==() without conversion. */
	inline bool _eq(const daeIDREF_base *cmp)const
	{
		return 0==strcmp(data(),cmp->data())?_eq_etc_2(cmp):false;
	}	
	/** Implements @c operator>() without conversion. */
	inline bool _lt(const daeIDREF_base *cmp)const
	{
		return strcmp(data(),cmp->data())>0?_eq_etc_2(cmp):false;
	}
	/** Implements @c operator>() without conversion. */
	inline bool _gt(const daeIDREF_base *cmp)const
	{
		return strcmp(data(),cmp->data())<0?_eq_etc_2(cmp):false;
	}
	/** Implements document ownership semantics. */
	inline bool _eq_etc_2(const daeIDREF_base *cmp)const
	{
		if(getIsDocumentAgnostic()||cmp->getIsDocumentAgnostic()) return true;
		const daeDoc *doc = _support::getDoc(); 
		if(doc==nullptr) return true;		
		const daeDoc *doc2 = cmp->getDoc(); 
		if(doc2==nullptr) return true; return doc==doc2;
	}

COLLADA_(public) //ACCESSORS & MUTATORS	
	/** 
	 * Gets the internal @c global flag. A global ID is not bound
	 * to a document. It is treated as a strictly reusable string.
	 * @see @c daeDefaultIDREFResolver::_resolve().
	 */
	inline bool getIsDocumentAgnostic()const{ return _getFlags().global!=0; }
	/** 
	 * Sets the internal @c global flag. A global ID is not bound
	 * to a document. It is treated as a strictly reusable string.
	 * @see @c daeDefaultIDREFResolver::_resolve().
	 */
	inline void getIsDocumentAgnostic(bool flag=true){ _getFlags().global = flag?1:0; }
		
	/**
	 * Sets the pointer to the @c daeObject that contains this ref.
	 * @param c the containing @c daeObject.
	 */
	inline daeOK setParentObject(const daeObject *c)
	{
		assert(c!=nullptr);
		return _support::_reparent(*c); //NOT MANAGING daeStringRef RIGHT NOW.
	}
	#ifndef COLLADA_NODEPRECATED
	COLLADA_DEPRECATED("setParentObject")
	/**LEGACY
	 * Sets the pointer to the @c daeElement that contains this ref.
	 * @param c Pointer to the containing @c daeElmement.
	 */
	void setContainer(const daeElement *c)
	{
		if(setParentObject(c==nullptr?*this:*c)!=DAE_OK) assert(0);
	}
	#endif //COLLADA_NODEPRECATED

	/**
	 * Resets this @c daeIDREF; freeing all string references.
	 */
	inline void clear()const{ _this()._refString.setString(*this,""); }

	/**Standard Library support 
	 */
	inline daeString data()const{ return ((Type&)*this)._refString._varray; }
	/**Standard Library support 
	 * Tells if @c size() is 0.
	 * If @c clear() exists, then it follows that @c empty() should. 
	 */
	inline bool empty()const{ return '\0'==*data(); }
	/**Standard Library support 
	 * Gets the size minus, excluding the 0 terminator.
	 * If @c clear() exists, then it follows that @c size() should. 
	 */
	inline size_t size()const{ return strlen(data()); }	

COLLADA_(public) //FORWARDED CONSTRUCTORS
	/**
	 * Default Constructor
	 */
	daeIDREF_base():COLLADA_SUPPRESS_C(4355)_support(this){}
	/**
	 * @a Type Copy Constructor
	 */
	daeIDREF_base(const daeIDREF_base &cp){ *this = cp; }
	
	template<class T>
	/**
	 * Explicit Constructor
	 */
	explicit daeIDREF_base(const T &ref)
	{
		_this()._refString.setString(*this,daeHashString(ref)); 
	}
	template<class T>
	/**
	 * Constructor having @c this contained by @a c.
	 * @param c_str is now required to supply a parent object.
	 * This is so the constructor is not ambiguous. 
	 * @c DAEP::InnerValue uses this constructor to supply an
	 * object. @c c is a @c daeRef_support::__COLLADA__Object.
	 */
	daeIDREF_base(const T &ref, const DAEP::Object *c):_support(c)
	{
		_this()._refString.setString(*this,daeHashString(ref)); 
	}
};

template<int size_on_stack> 
/**VARIABLE-LENGTH
 * @c daeIDREF is a fixed size @c typedef of @c daeIDREF_size.
 * @tparam size_on_stack can be any size; 0 is fully dynamic.
 * (UPDATE: 0 is not fully dynamic, although this might change.)
 *
 * FUTURE WORK?
 * @remarks The refs are not @c daeStringRef based. They could 
 * be made to use @c daeRefString::setView(), which wouldn't break
 * inlined code if changed. "setView" is not @c daeStringRef aware. 
 * (@c daeIDREF_size would have to call "isView" to manage it.)
 */
class daeIDREF_size : public daeIDREF_base<daeIDREF>
{	
	friend class daeIDREF_base<daeIDREF_size>;

COLLADA_(protected) //daeIDREF_base data
	/** 
	 * Multi-representational string. 
	 */
	daeRefString<size_on_stack> _refString;

COLLADA_(public) //daeIDREF_base methods

	/** Statically shadows @c daeRef::getRefType(). */
	static int getRefType(){ return daeRefType::IDREF; }

COLLADA_(public) //OPERATORS

	//using daeIDREF_base<daeIDREF>::operator=;
	template<class T>
	COLLADA_SUPPRESS_C(4522)
	/** Pass-through Assignment Operator */
	daeIDREF &operator=(const T &cp){ return daeIDREF_base::operator=(cp); }	
	COLLADA_SUPPRESS_C(4522)
	/**C++ Non-Default Assignment Operator */
	daeIDREF &operator=(const daeIDREF_size &cp){ return daeIDREF_base::operator=(cp); }	

COLLADA_(public) //FORWARDING CONSTRUCTORS
	/**
	 * Default Constructor
	 */
	daeIDREF_size(){}	

	//Marking explcit, just to be safe.
	template<class S>
	/** Single Argument Forwarded Copy Constructor. */
	explicit daeIDREF_size(const S &s):daeIDREF_base(s){}
	/** Non-Default Copy Constructor (same as above) */
	daeIDREF_size(const daeIDREF_size &cp):daeIDREF_base(cp){}

	template<class S, class T>
	/** Two Argument Forwarded Copy Constructor. */
	daeIDREF_size(const S &s, const T &t):daeIDREF_base(s,t){}

COLLADA_(public) //METHODS NAMED AFTER IDREF

	template<class T>
	/**
	 * Assigns @a ref to the  @c _refString data member.
	 * @param ref String to use to configure this @c daeIDREF.
	 */
	inline void setIDREF(const T &ref)
	{
		_refString.setString(*this,daeHashString(ref)); 
	}
	template<class T> 
	/**
	 * Gets the entire IDREF to a @a T. 
	 * @see no-argument form's Doxygentation.
	 */
	inline T &getIDREF(T &io)const
	{
		daeString s = _refString.getString();
		return _getT(io,s,strlen(s)+1); 
	}	
	/**LEGACY-SUPPORT
	 * Gets the IDREF string consistent with @c daeURI::getURI().
	 * @see @c data() to get a C-string.
	 * @remark @c daeIDREF and @c daeSIDREF don't store the size
	 * of their strings. That may change if there is an argument
	 * to. This API calls @c strlen(). Use @c data() to avoid it.
	 * Optimization will likely eliminate the length if not used.
	 */	
	inline daeRefView_0 getIDREF()const
	{
		daeRefView_0 o; o.view = _refString.getString();
		o.extent = strlen(o.view); return o;
	} 		  	

	#ifndef COLLADA_NODEPRECATED	
	template<class T>
	COLLADA_DEPRECATED("setIDREF") //MSVC wants below.
	/**
	 * Assigns @a ref to the  @c _refString data member.
	 * @param ref String to use to configure this @c daeIDREF.
	 */
	inline void setID(const T &ref){ setIDREF(ref); }	
	COLLADA_DEPRECATED("getIDREF")
	/**DEPRECATED
	 * Gets the IDREF string
	 * @return Returns the full IDREF string from @c _refString. 
	 * @see @c daeString operator, implicit cast.
	 */
	inline daeString getID()const{ return getIDREF(); }	
	#endif //COLLADA_NODEPRECATED
};

/**
 * The @c daeDefaultIDREFResolver resolves a @c daeIDREF by way of
 * the @c daeDocument class's indexing-services. If ID indexing is 
 * not yet enabled, it will be, in which case, the document will be
 * immediately scanned for all IDs (Note: ID is hardwired into XML.)
 * It is a concrete implementation of @c daeRefResolver.
 *
 * Old @c daeDefaultIDRefResolver::resolveElement() API
 * ====================================================
 * @see @c daeDocument::idLookup(). (There's no reason to use this.)
 */
class daeDefaultIDREFResolver : public daeRefResolver
{	
COLLADA_(public) //daeContainedObject method

	/**PURE-OVERRIDE */
	virtual void __daeContainedObject__v1__atomize(){ /*NOP*/ }

COLLADA_(public) //public daeRefResolver methods
		
	static daeClientString getRefResolverNameString()
	{
		return "Default IDREF Resolver (daeDefaultIDREFResolver)"; 
	}
	/**PURE-OVERRIDE */
	virtual daeClientString getName()const{ return getRefResolverNameString(); }

COLLADA_(public) 
	/**
	 * Default Constructor
	 */
	daeDefaultIDREFResolver():daeRefResolver(daeRefType::IDREF){} 

	/** 
	 * This is making use of the resolver, independently of 
	 * @c RefResolverList. (It uses @c _resolve() instead.)
	 */
	inline daeOK resolve(const daeIDREF &IDREF, daeRefRequest &req)const
	{
		return _resolve(IDREF,req);
	}

COLLADA_(protected) //daeRefResolver::_resolve

	virtual daeOK _resolve(const daeRef &ref, daeRefRequest &req)const
	{
		const_daeDocRef doc;
		const daeIDREF &idref = (daeIDREF&)ref;		

		//COLLADA_SUPPRESS_C(4144)
		switch(req.object!=nullptr?1:0)
		{
		case 1: doc = req.object->getDoc();

			if(doc!=nullptr) 
			{
				if(!idref.getIsDocumentAgnostic())
				{
					const daeDoc *cmp = ref.getDoc();

					if(cmp!=nullptr&&doc!=cmp) return DAE_ERR_QUERY_SYNTAX;
				}
				break;
			}
			//break; //falling-through!

		case 0:	doc = ref.getDoc();

			if(doc==nullptr) return DAE_ERR_INVALID_CALL;
		}		

		if(req!=nullptr)
		{
			//no special commands are being supported
			assert(0); return DAE_ERR_NOT_IMPLEMENTED;
		}

		//assuming an ID search is final
		doc->getDocument()->idLookup(idref.getIDREF(),req.object); return DAE_OK;
	}
};

//---.
}//<-'

#endif //__COLLADA_DOM__DAE_IDREF_H__
/*C1071*/